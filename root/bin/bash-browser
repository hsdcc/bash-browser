#!/bin/bash

get_term_size() {
  # This uses an alternative escape sequence (\e[18t) to get terminal size,
  # which has proven to be more reliable.
  # Response format: \e[8;<height>;<width>t
  printf '\e[18t' >/dev/tty

  local response
  read -s -t 1 -d t response </dev/tty

  if [[ -n "$response" && "$response" == *";"* && "$response" == *"8;"* ]]; then
    response=${response#*;} # Remove leading junk up to first ;
    term_height=${response%;*}
    term_width=${response#*;} # Remove leading junk up to first ;
  fi

  # Fallback if detection fails
  term_height=${term_height:-24}
  term_width=${term_width:-80}
}

if [ $# -eq 0 ]; then
  echo "usage: bash-browser <url>"
  exit 1
fi

url="$1"
echo "loading..."

echo "fetching: $url"

# Use the curl script to download content
content="$("/home/meow/code/bash-browser/root/bin/curl" "$url")"
if [ $? -ne 0 ]; then
  echo "error: could not fetch content from $url"
  exit 1
fi

# Basic HTML tag stripping and decoding, optimized to run on the whole content at once.

# 1. Remove HTML comments using pure bash
# This is still iterative, but runs on the whole buffer, not line-by-line
while [[ "$content" == *"<!--"*"-->"* ]]; do
  start_comment="${content%%<!--*}"
  end_comment="${content#*-->}"
  content="${start_comment}${end_comment}"
done

# 1.5. Process <a> tags to make links visible: <a href="URL">TEXT</a> -> TEXT [URL]
# This is a simplified parser that handles <a href="..."> but not other attributes well.
while [[ "$content" == *"<a href="* && "$content" == *"</a>"* ]]; do
  pre_a_tag="${content%%<a href=*}"
  rest="${content#*<a href=*}"

  quote_char="${rest:0:1}"
  if [[ "$quote_char" != '"' && "$quote_char" != "'" ]]; then
    # Could not find quote, skip this tag to avoid infinite loop
    content="${pre_a_tag}${rest}"
    continue
  fi

  rest_no_quote="${rest#"$quote_char"}"
  url="${rest_no_quote%%"$quote_char"*}"

  # Ensure we have a closing > for the <a> tag
  if [[ "$rest" != *">"* ]]; then
    content="${pre_a_tag}${rest}"
    continue
  fi

  text_and_post="${rest#*>}"
  text="${text_and_post%%</a>*}"
  post_a_tag="${text_and_post#*</a>}"

  content="${pre_a_tag}${text} [${url}]${post_a_tag}"
done

# 2. Replace certain closing tags with newlines before removing all other tags
# Handle h1-h6 tags
content="${content//<\/h1>/$'\n'$'\n'}"
content="${content//<\/h2>/$'\n'$'\n'}"
content="${content//<\/h3>/$'\n'$'\n'}"
content="${content//<\/h4>/$'\n'$'\n'}"
content="${content//<\/h5>/$'\n'$'\n'}"
content="${content//<\/h6>/$'\n'$'\n'}"
# Other block-level tags
content="${content//<\/p>/$'\n'$'\n'}"
content="${content//<br>/$'\n'}"
content="${content//<br\/>/$'\n'}"
content="${content//<br \/>/$'\n'}"
content="${content//<\/li>/$'\n'}"
content="${content//<\/div>/$'\n'}"
content="${content//<\/tr>/$'\n'}"
content="${content//<\/td>/	}" # tab character
content="${content//<\/th>/	}" # tab character

# 3. Remove all remaining HTML tags iteratively
# This is the main bottleneck, but necessary for correctness in pure bash
while [[ "$content" == *"<"*">"* ]]; do
  start_part="${content%%<*}"
  remaining="${content#*>}"
  content="${start_part}${remaining}"
done

# 4. Decode common HTML entities
content="${content//&amp;/&}"
content="${content//&lt;/<}"
content="${content//&gt;/>}"
content="${content//&quot;/\"}"
content="${content//&#39;/\'}"

# 5. Clean up extra blank lines
# The previous steps can create lots of consecutive newlines, this collapses them.
# Replace three or more newlines with two.
while [[ "$content" == *$'\n\n\n'* ]]; do
  content="${content//$'\n\n\n'/$'\n\n'}"
done

# --- scrolling implementation ---

follow_links() {
  local visible_links=()
  local link_positions=()
  local hint_chars="asdfjklgh"
  declare -A hint_lookup

  # Pattern to find http(s) URLs, excluding common trailing characters
  local url_pattern='https?://[^][<>"[:space:]]*'

  for ((i = 0; i < view_height; i++)); do
    local line_index=$((offset + i))
    [ $line_index -ge $line_count ] && break

    local line_content="${lines[$line_index]}"
    local col_offset=0

    while [[ "$line_content" =~ $url_pattern ]]; do
      local url="${BASH_REMATCH[0]}"
      local pre_match="${line_content%%"$url"*}"
      local col=$((col_offset + ${#pre_match} + 1))

      visible_links+=("$url")
      link_positions+=("$((i + 1));$col")

      local consumed_part="${pre_match}${url}"
      line_content="${line_content#"${consumed_part}"}"
      col_offset=$((col_offset + ${#consumed_part}))
    done
  done

  if [ ${#visible_links[@]} -eq 0 ]; then
    printf "\e[${height};0H\e[41m"
    printf "%-${term_width}s" "No links found on screen."
    printf "\e[0m"
    sleep 1
    return
  fi

  for i in "${!visible_links[@]}"; do
    local pos="${link_positions[$i]}"
    local screen_line="${pos%%;*}"
    local screen_col="${pos#*;}"
    local hint_char="${hint_chars:$i:1}"

    [ -z "$hint_char" ] && break

    hint_lookup["$hint_char"]="$i"

    printf "\e[%s;%sH\e[42;30m[%s]\e[0m" "$screen_line" "$screen_col" "$hint_char"
  done

  printf "\e[${height};0H\e[44m"
  printf "%-${term_width}s" "Type hint to follow link, or any other key to cancel."
  printf "\e[0m"

  read -s -n 1 key

  local link_index="${hint_lookup[$key]}"
  if [[ -n "$link_index" ]]; then
    local target_url="${visible_links[$link_index]}"

    printf "\e[?25h\033c"

    # Handle root-relative URLs like /foo/bar
    if [[ "$target_url" != "http"* ]]; then
      if [[ "$target_url" == "/"* ]]; then
        local protocol="${url%%://*}"
        local tmp="${url#*//}"
        local host="${tmp%%/*}"
        target_url="${protocol}://${host}${target_url}"
      else
        printf "\e[${height};0H\e[41m"
        printf "%-${term_width}s" "Cannot follow relative URL: $target_url"
        printf "\e[0m"
        sleep 2
        return
      fi
    fi

    exec "$0" "$target_url"
  fi
  # If key is not a valid hint, we do nothing and the main loop will redraw the screen.
}

# store content in an array
mapfile -t lines <<<"$content"

# get terminal size
get_term_size
height=${term_height}

# leave room for status bar
view_height=$((height - 1))

offset=0
line_count=${#lines[@]}

# hide cursor
printf "\e[?25l"

while true; do
  # clear screen
  printf "\033c"

  # display content
  for ((i = 0; i < view_height; i++)); do
    line_index=$((offset + i))
    if [ $line_index -lt $line_count ]; then
      echo "${lines[$line_index]}"
    fi
  done

  # status bar
  printf "\e[${height};0H" # move to last line
  printf "\e[44m"          # blue background
  status_text=$(printf "Line %s-%s/%s (j=down, k=up, q=quit, s=follow)" "$((offset + 1))" "$((offset + view_height))" "$line_count")
  printf "%-${term_width}s" "$status_text" # pad to full width
  printf "\e[0m"                           # reset color

  # get user input
  read -s -n 1 key

  case "$key" in
  'q')
    break
    ;;
  'j')
    # scroll down
    if [ $((offset + view_height)) -lt $line_count ]; then
      offset=$((offset + 1))
    fi
    ;;
  'k')
    # scroll up
    if [ $offset -gt 0 ]; then
      offset=$((offset - 1))
    fi
    ;;
  's')
    follow_links
    ;;
  esac
done

# show cursor and clear screen on exit
printf "\e[?25h"
printf "\033c"
