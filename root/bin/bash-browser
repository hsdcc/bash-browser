#!/bin/bash

get_term_size() {
    # This uses an alternative escape sequence (\e[18t) to get terminal size,
    # which has proven to be more reliable.
    # Response format: \e[8;<height>;<width>t
    printf '\e[18t' > /dev/tty
    
    local response
    read -s -t 1 -d t response < /dev/tty

    if [[ -n "$response" && "$response" == *";"* && "$response" == *"8;"* ]]; then
        response=${response#*;} # Remove leading junk up to first ;
        term_height=${response%;*}
        term_width=${response#*;} # Remove leading junk up to first ;
    fi

    # Fallback if detection fails
    term_height=${term_height:-24}
    term_width=${term_width:-80}
}

if [ $# -eq 0 ]; then
    echo "usage: bash-browser <url>"
    exit 1
fi

url="$1"
echo "loading..."

echo "fetching: $url"

# Use the curl script to download content
content="$("/home/meow/code/bash-browser/root/bin/curl" "$url")"
if [ $? -ne 0 ]; then
    echo "error: could not fetch content from $url"
    exit 1
fi

# Basic HTML tag stripping and decoding
# Remove HTML tags and comments, keeping the text content
clean_content=""
while IFS= read -r line; do
    processed_line="$line"
    
    # Remove HTML comments using pure bash
    while [[ "$processed_line" == *"<!--"*"-->"* ]]; do
        start_comment="${processed_line%%<!--*}"
        end_comment="${processed_line#*-->}"
        processed_line="${start_comment}${end_comment}"
    done
    
    # Decode common HTML entities  
    processed_line="${processed_line//&amp;/&}"
    processed_line="${processed_line//&lt;/<}"
    processed_line="${processed_line//&gt;/>}"
    processed_line="${processed_line//&quot;/\"}"
    processed_line="${processed_line//&#39;/\'}"
    
    # Replace certain closing tags with newlines before removing all tags
    # Handle h1-h6 tags
    processed_line="${processed_line//<\/h1>/$'\n'$'\n'}"
    processed_line="${processed_line//<\/h2>/$'\n'$'\n'}"
    processed_line="${processed_line//<\/h3>/$'\n'$'\n'}"
    processed_line="${processed_line//<\/h4>/$'\n'$'\n'}"
    processed_line="${processed_line//<\/h5>/$'\n'$'\n'}"
    processed_line="${processed_line//<\/h6>/$'\n'$'\n'}"
    
    # Replace other tags with newlines
    processed_line="${processed_line//<\/p>/$'\n'$'\n'}"
    processed_line="${processed_line//<br>/$'\n'}"
    processed_line="${processed_line//<br\/>/$'\n'}"
    processed_line="${processed_line//<br \/>/$'\n'}"
    processed_line="${processed_line//<\/li>/$'\n'}"
    processed_line="${processed_line//<\/div>/$'\n'}"
    processed_line="${processed_line//<\/tr>/$'\n'}"
    processed_line="${processed_line//<\/td>/	}"  # tab character
    processed_line="${processed_line//<\/th>/	}"  # tab character
    
    # Remove all remaining HTML tags iteratively
    while [[ "$processed_line" == *"<"*">"* ]]; do
        start_part="${processed_line%%<*}"
        remaining="${processed_line#*>}"
        processed_line="${start_part}${remaining}"
    done
    
    # Add non-empty lines of content to clean_content
    if [[ -n "$processed_line" ]]; then
        clean_content+="$processed_line"$'\n'
    fi
done <<< "$content"

# Update content variable with cleaned content
content="$clean_content"

# --- scrolling implementation ---
    
# store content in an array
mapfile -t lines <<< "$content"
    
# get terminal size
get_term_size
height=${term_height}
    
# leave room for status bar
view_height=$((height - 1))
    
offset=0
line_count=${#lines[@]}
    
# hide cursor
printf "\e[?25l"
    
while true; do
    # clear screen
    printf "\033c"
        
    # display content
    for ((i=0; i<view_height; i++)); do
        line_index=$((offset + i))
        if [ $line_index -lt $line_count ]; then
            echo "${lines[$line_index]}"
        fi
    done
        
    # status bar
    printf "\e[${height};0H" # move to last line
    printf "\e[44m" # blue background
    status_text=$(printf "Line %s-%s/%s (j=down, k=up, q=quit)" "$((offset + 1))" "$((offset + view_height))" "$line_count")
    printf "%-${term_width}s" "$status_text" # pad to full width
    printf "\e[0m" # reset color
        
    # get user input
    read -s -n 1 key
        
    case "$key" in
        'q')
            break
            ;;
        'j')
            # scroll down
            if [ $((offset + view_height)) -lt $line_count ]; then
                offset=$((offset + 1))
            fi
            ;;
        'k')
            # scroll up
            if [ $offset -gt 0 ]; then
                offset=$((offset - 1))
            fi
            ;;
    esac
done
    
# show cursor and clear screen on exit
printf "\e[?25h"
printf "\033c"
    

