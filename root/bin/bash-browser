#!/bin/bash

get_term_size() {
    # This uses an alternative escape sequence (\e[18t) to get terminal size,
    # which has proven to be more reliable.
    # Response format: \e[8;<height>;<width>t
    printf '\e[18t' > /dev/tty
    
    local response
    read -s -t 1 -d t response < /dev/tty

    if [[ -n "$response" && "$response" == *";"* && "$response" == *"8;"* ]]; then
        response=${response#*;} # Remove leading junk up to first ;
        term_height=${response%;*}
        term_width=${response#*;} # Remove leading junk up to first ;
    fi

    # Fallback if detection fails
    term_height=${term_height:-24}
    term_width=${term_width:-80}
}

if [ $# -eq 0 ]; then
    echo "usage: bash-browser <url>"
    exit 1
fi

url="$1"
echo "loading..."

echo "fetching: $url"

# Use the curl script to download content
content="$("/home/meow/code/bash-browser/root/bin/curl" "$url")"
if [ $? -ne 0 ]; then
    echo "error: could not fetch content from $url"
    exit 1
fi

# Basic HTML tag stripping and decoding, optimized to run on the whole content at once.

# 1. Remove HTML comments using pure bash
# This is still iterative, but runs on the whole buffer, not line-by-line
while [[ "$content" == *"<!--"*"-->"* ]]; do
    start_comment="${content%%<!--*}"
    end_comment="${content#*-->}"
    content="${start_comment}${end_comment}"
done

# 2. Replace certain closing tags with newlines before removing all other tags
# Handle h1-h6 tags
content="${content//<\/h1>/$'\n'$'\n'}"
content="${content//<\/h2>/$'\n'$'\n'}"
content="${content//<\/h3>/$'\n'$'\n'}"
content="${content//<\/h4>/$'\n'$'\n'}"
content="${content//<\/h5>/$'\n'$'\n'}"
content="${content//<\/h6>/$'\n'$'\n'}"
# Other block-level tags
content="${content//<\/p>/$'\n'$'\n'}"
content="${content//<br>/$'\n'}"
content="${content//<br\/>/$'\n'}"
content="${content//<br \/>/$'\n'}"
content="${content//<\/li>/$'\n'}"
content="${content//<\/div>/$'\n'}"
content="${content//<\/tr>/$'\n'}"
content="${content//<\/td>/	}"  # tab character
content="${content//<\/th>/	}"  # tab character

# 3. Remove all remaining HTML tags iteratively
# This is the main bottleneck, but necessary for correctness in pure bash
while [[ "$content" == *"<"*">"* ]]; do
    start_part="${content%%<*}"
    remaining="${content#*>}"
    content="${start_part}${remaining}"
done

# 4. Decode common HTML entities  
content="${content//&amp;/&}"
content="${content//&lt;/<}"
content="${content//&gt;/>}"
content="${content//&quot;/\"}"
content="${content//&#39;/\'}"

# 5. Clean up extra blank lines
# The previous steps can create lots of consecutive newlines, this collapses them.
# Replace three or more newlines with two.
while [[ "$content" == *$'\n\n\n'* ]]; do
    content="${content//$'\n\n\n'/$'\n\n'}"
done

# --- scrolling implementation ---
    
# store content in an array
mapfile -t lines <<< "$content"
    
# get terminal size
get_term_size
height=${term_height}
    
# leave room for status bar
view_height=$((height - 1))
    
offset=0
line_count=${#lines[@]}
    
# hide cursor
printf "\e[?25l"
    
while true; do
    # clear screen
    printf "\033c"
        
    # display content
    for ((i=0; i<view_height; i++)); do
        line_index=$((offset + i))
        if [ $line_index -lt $line_count ]; then
            echo "${lines[$line_index]}"
        fi
    done
        
    # status bar
    printf "\e[${height};0H" # move to last line
    printf "\e[44m" # blue background
    status_text=$(printf "Line %s-%s/%s (j=down, k=up, q=quit)" "$((offset + 1))" "$((offset + view_height))" "$line_count")
    printf "%-${term_width}s" "$status_text" # pad to full width
    printf "\e[0m" # reset color
        
    # get user input
    read -s -n 1 key
        
    case "$key" in
        'q')
            break
            ;;
        'j')
            # scroll down
            if [ $((offset + view_height)) -lt $line_count ]; then
                offset=$((offset + 1))
            fi
            ;;
        'k')
            # scroll up
            if [ $offset -gt 0 ]; then
                offset=$((offset - 1))
            fi
            ;;
    esac
done
    
# show cursor and clear screen on exit
printf "\e[?25h"
printf "\033c"
    

